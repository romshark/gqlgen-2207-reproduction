// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type E1 string

const (
	E1True E1 = "true"
	E1Okay E1 = "okay"
)

var AllE1 = []E1{
	E1True,
	E1Okay,
}

func (e E1) IsValid() bool {
	switch e {
	case E1True, E1Okay:
		return true
	}
	return false
}

func (e E1) String() string {
	return string(e)
}

func (e *E1) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = E1(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid E1", str)
	}
	return nil
}

func (e E1) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type E2 string

const (
	E2False E2 = "false"
	E2Okay  E2 = "okay"
)

var AllE2 = []E2{
	E2False,
	E2Okay,
}

func (e E2) IsValid() bool {
	switch e {
	case E2False, E2Okay:
		return true
	}
	return false
}

func (e E2) String() string {
	return string(e)
}

func (e *E2) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = E2(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid E2", str)
	}
	return nil
}

func (e E2) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type E3 string

const (
	E3Null E3 = "null"
	E3Okay E3 = "okay"
)

var AllE3 = []E3{
	E3Null,
	E3Okay,
}

func (e E3) IsValid() bool {
	switch e {
	case E3Null, E3Okay:
		return true
	}
	return false
}

func (e E3) String() string {
	return string(e)
}

func (e *E3) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = E3(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid E3", str)
	}
	return nil
}

func (e E3) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
